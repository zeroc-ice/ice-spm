//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.7
//
// <auto-generated>
//
// Generated from file `Current.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation

/// A request context. Context is used to transmit metadata about a
/// request from the server to the client, such as Quality-of-Service
/// (QoS) parameters. Each operation on the client has a Context as
/// its implicit final parameter.
public typealias Context = [Swift.String: Swift.String]

/// Helper class to read and write `Context` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ContextHelper {
    /// Read a `Context` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `Context` - The dictionary read from the stream.
    public static func read(from istr: InputStream) throws -> Context {
        let sz = try Swift.Int(istr.readSize())
        var v = Context()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `Context?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Context` - The dictionary read from the stream.
    public static func read(from istr: InputStream, tag: Swift.Int32) throws -> Context? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `Context` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `Context` - The dictionary value to write to the stream.
    public static func write(to ostr: OutputStream, value v: Context) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `Context?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Context` - The dictionary value to write to the stream.
    public static func write(to ostr: OutputStream, tag: Swift.Int32, value v: Context?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Determines the retry behavior an invocation in case of a (potentially) recoverable error.
public enum OperationMode: Swift.UInt8 {
    /// Normal Ordinary operations have Normal mode.  These operations
    /// modify object state; invoking such an operation twice in a row
    /// has different semantics than invoking it once. The Ice run time
    /// guarantees that it will not violate at-most-once semantics for
    /// Normal operations.
    case Normal = 0
    /// `Nonmutating` Operations that use the Slice nonmutating keyword must not
    /// modify object state. For C++, nonmutating operations generate
    /// const member functions in the skeleton. In addition, the Ice
    /// run time will attempt to transparently recover from certain
    /// run-time errors by re-issuing a failed request and propagate
    /// the failure to the application only if the second attempt
    /// fails.
    ///
    /// Nonmutating is deprecated; Use the
    /// idempotent keyword instead. For C++, to retain the mapping
    /// of nonmutating operations to C++ const
    /// member functions, use the \["cpp:const"] metadata
    /// directive.
    case `Nonmutating` = 1
    /// Idempotent Operations that use the Slice idempotent keyword can modify
    /// object state, but invoking an operation twice in a row must
    /// result in the same object state as invoking it once.  For
    /// example, x = 1 is an idempotent statement,
    /// whereas x += 1 is not. For idempotent
    /// operations, the Ice run-time uses the same retry behavior
    /// as for nonmutating operations in case of a potentially
    /// recoverable error.
    case Idempotent = 2
    public init() {
        self = .Normal
    }
}

/// An `Ice.InputStream` extension to read `OperationMode` enumerated values from the stream.
public extension InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `OperationMode` - The enumarated value.
    func read() throws -> OperationMode {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = OperationMode(rawValue: rawValue) else {
            throw MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `OperationMode` - The enumerated value.
    func read(tag: Swift.Int32) throws -> OperationMode? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as OperationMode
    }
}

/// An `Ice.OutputStream` extension to write `OperationMode` enumerated values to the stream.
public extension OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `OperationMode` - The enumerator to write.
    func write(_ v: OperationMode) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `OperationMode` - The enumerator to write.
    func write(tag: Swift.Int32, value: OperationMode?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

/// Information about the current method invocation for servers. Each
/// operation on the server has a Current as its implicit final
/// parameter. Current is mostly used for Ice services. Most
/// applications ignore this parameter.
public class Current {
    /// The object adapter.
    public var adapter: ObjectAdapter? = nil
    /// Information about the connection over which the current method
    /// invocation was received. If the invocation is direct due to
    /// collocation optimization, this value is set to null.
    public var con: Connection? = nil
    /// The Ice object identity.
    public var id: Identity = Identity()
    /// The facet.
    public var facet: Swift.String = ""
    /// The operation name.
    public var operation: Swift.String = ""
    /// The mode of the operation.
    public var mode: OperationMode = .Normal
    /// The request context, as received from the client.
    public var ctx: Context = Context()
    /// The request id unless oneway (0).
    public var requestId: Swift.Int32 = 0
    /// The encoding version used to encode the input and output parameters.
    public var encoding: EncodingVersion = EncodingVersion()

    public init() {}

    public init(adapter: ObjectAdapter?, con: Connection?, id: Identity, facet: Swift.String, operation: Swift.String, mode: OperationMode, ctx: Context, requestId: Swift.Int32, encoding: EncodingVersion) {
        self.adapter = adapter
        self.con = con
        self.id = id
        self.facet = facet
        self.operation = operation
        self.mode = mode
        self.ctx = ctx
        self.requestId = requestId
        self.encoding = encoding
    }
}
