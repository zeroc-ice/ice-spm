//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.7
//
// <auto-generated>
//
// Generated from file `Locator.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import PromiseKit

/// :nodoc:
public class AdapterNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return AdapterNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_AdapterNotFoundException() -> UserExceptionTypeResolver {
        return AdapterNotFoundException_TypeResolver()
    }
}

/// This exception is raised if an adapter cannot be found.
open class AdapterNotFoundException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::AdapterNotFoundException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: AdapterNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class InvalidReplicaGroupIdException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return InvalidReplicaGroupIdException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_InvalidReplicaGroupIdException() -> UserExceptionTypeResolver {
        return InvalidReplicaGroupIdException_TypeResolver()
    }
}

/// This exception is raised if the replica group provided by the
/// server is invalid.
open class InvalidReplicaGroupIdException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::InvalidReplicaGroupIdException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: InvalidReplicaGroupIdException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AdapterAlreadyActiveException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return AdapterAlreadyActiveException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_AdapterAlreadyActiveException() -> UserExceptionTypeResolver {
        return AdapterAlreadyActiveException_TypeResolver()
    }
}

/// This exception is raised if a server tries to set endpoints for
/// an adapter that is already active.
open class AdapterAlreadyActiveException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::AdapterAlreadyActiveException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: AdapterAlreadyActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class ObjectNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return ObjectNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_ObjectNotFoundException() -> UserExceptionTypeResolver {
        return ObjectNotFoundException_TypeResolver()
    }
}

/// This exception is raised if an object cannot be found.
open class ObjectNotFoundException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::ObjectNotFoundException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: ObjectNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class ServerNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return ServerNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_ServerNotFoundException() -> UserExceptionTypeResolver {
        return ServerNotFoundException_TypeResolver()
    }
}

/// This exception is raised if a server cannot be found.
open class ServerNotFoundException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::ServerNotFoundException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: ServerNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `Locator`.
public struct LocatorTraits: SliceTraits {
    public static let staticIds = ["::Ice::Locator", "::Ice::Object"]
    public static let staticId = "::Ice::Locator"
}

/// Traits for Slice interface `LocatorRegistry`.
public struct LocatorRegistryTraits: SliceTraits {
    public static let staticIds = ["::Ice::LocatorRegistry", "::Ice::Object"]
    public static let staticId = "::Ice::LocatorRegistry"
}

/// Traits for Slice interface `LocatorFinder`.
public struct LocatorFinderTraits: SliceTraits {
    public static let staticIds = ["::Ice::LocatorFinder", "::Ice::Object"]
    public static let staticId = "::Ice::LocatorFinder"
}

/// The Ice locator interface. This interface is used by clients to
/// lookup adapters and objects. It is also used by servers to get the
/// locator registry proxy.
///
/// The Locator interface is intended to be used by
/// Ice internals and by locator implementations. Regular user code
/// should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorPrx Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findObjectByIdAsync: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - findAdapterByIdAsync: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
///
///  - getRegistryAsync: Get the locator registry.
public protocol LocatorPrx: ObjectPrx {}

internal final class LocatorPrxI: ObjectPrxI, LocatorPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) throws -> LocatorPrx? {
    return try LocatorPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil) -> LocatorPrx {
    return LocatorPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `LocatorPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: LocatorPrx.Protocol) -> Swift.String {
    return LocatorTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx?` - The extracted proxy
    func read(_ type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read() as LocatorPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read(tag: tag) as LocatorPrxI?
    }
}

/// The Ice locator interface. This interface is used by clients to
/// lookup adapters and objects. It is also used by servers to get the
/// locator registry proxy.
///
/// The Locator interface is intended to be used by
/// Ice internals and by locator implementations. Regular user code
/// should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorPrx Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findObjectByIdAsync: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - findAdapterByIdAsync: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
///
///  - getRegistryAsync: Get the locator registry.
public extension LocatorPrx {
    /// Find an object by identity and return a proxy that contains
    /// the adapter ID or endpoints which can be used to access the
    /// object.
    ///
    /// - parameter _: `Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectPrx?` - The proxy, or null if the object is not active.
    ///
    /// - throws:
    ///
    ///   - ObjectNotFoundException - Raised if the object cannot
    ///     be found.
    func findObjectById(_ iceP_id: Identity, context: Context? = nil) throws -> ObjectPrx? {
        return try _impl._invoke(operation: "findObjectById",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ObjectNotFoundException {
                                         throw error
                                     } catch is UserException {}
                                 },
                                 context: context)
    }

    /// Find an object by identity and return a proxy that contains
    /// the adapter ID or endpoints which can be used to access the
    /// object.
    ///
    /// - parameter _: `Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ObjectPrx?>` - The result of the operation
    func findObjectByIdAsync(_ iceP_id: Identity, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ObjectPrx?> {
        return _impl._invokeAsync(operation: "findObjectById",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObjectNotFoundException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Find an adapter by id and return a proxy that contains
    /// its endpoints.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectPrx?` - The adapter proxy, or null if the adapter is not active.
    ///
    /// - throws:
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be
    ///     found.
    func findAdapterById(_ iceP_id: Swift.String, context: Context? = nil) throws -> ObjectPrx? {
        return try _impl._invoke(operation: "findAdapterById",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as AdapterNotFoundException {
                                         throw error
                                     } catch is UserException {}
                                 },
                                 context: context)
    }

    /// Find an adapter by id and return a proxy that contains
    /// its endpoints.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ObjectPrx?>` - The result of the operation
    func findAdapterByIdAsync(_ iceP_id: Swift.String, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ObjectPrx?> {
        return _impl._invokeAsync(operation: "findAdapterById",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterNotFoundException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the locator registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LocatorRegistryPrx?` - The locator registry.
    func getRegistry(context: Context? = nil) throws -> LocatorRegistryPrx? {
        return try _impl._invoke(operation: "getRegistry",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: LocatorRegistryPrx? = try istr.read(LocatorRegistryPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the locator registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<LocatorRegistryPrx?>` - The result of the operation
    func getRegistryAsync(context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<LocatorRegistryPrx?> {
        return _impl._invokeAsync(operation: "getRegistry",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: LocatorRegistryPrx? = try istr.read(LocatorRegistryPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The Ice locator registry interface. This interface is used by
/// servers to register adapter endpoints with the locator.
///
/// The LocatorRegistry interface is intended to be used
/// by Ice internals and by locator implementations. Regular user
/// code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistryPrx Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
///
///  - setServerProcessProxyAsync: Set the process proxy for a server.
public protocol LocatorRegistryPrx: ObjectPrx {}

internal final class LocatorRegistryPrxI: ObjectPrxI, LocatorRegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorRegistryTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorRegistryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorRegistryPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) throws -> LocatorRegistryPrx? {
    return try LocatorRegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorRegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorRegistryPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorRegistryPrx.Protocol, facet: Swift.String? = nil) -> LocatorRegistryPrx {
    return LocatorRegistryPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorRegistryPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `LocatorRegistryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: LocatorRegistryPrx.Protocol) -> Swift.String {
    return LocatorRegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorRegistryPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorRegistryPrx?` - The extracted proxy
    func read(_ type: LocatorRegistryPrx.Protocol) throws -> LocatorRegistryPrx? {
        return try read() as LocatorRegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorRegistryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorRegistryPrx.Protocol) throws -> LocatorRegistryPrx? {
        return try read(tag: tag) as LocatorRegistryPrxI?
    }
}

/// The Ice locator registry interface. This interface is used by
/// servers to register adapter endpoints with the locator.
///
/// The LocatorRegistry interface is intended to be used
/// by Ice internals and by locator implementations. Regular user
/// code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistryPrx Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
///
///  - setServerProcessProxyAsync: Set the process proxy for a server.
public extension LocatorRegistryPrx {
    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same
    ///     id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot
    ///     be found, or if the locator only allows
    ///     registered adapters to set their active proxy and the
    ///     adapter is not registered with the locator.
    func setAdapterDirectProxy(id iceP_id: Swift.String, proxy iceP_proxy: ObjectPrx?, context: Context? = nil) throws {
        try _impl._invoke(operation: "setAdapterDirectProxy",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_id)
                              ostr.write(iceP_proxy)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AdapterAlreadyActiveException {
                                  throw error
                              } catch let error as AdapterNotFoundException {
                                  throw error
                              } catch is UserException {}
                          },
                          context: context)
    }

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setAdapterDirectProxyAsync(id iceP_id: Swift.String, proxy iceP_proxy: ObjectPrx?, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setAdapterDirectProxy",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_proxy)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterAlreadyActiveException {
                                          throw error
                                      } catch let error as AdapterNotFoundException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter adapterId: `Swift.String` The adapter id.
    ///
    /// - parameter replicaGroupId: `Swift.String` The replica group id.
    ///
    /// - parameter p: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same
    ///     id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot
    ///     be found, or if the locator only allows registered adapters to
    ///     set their active proxy and the adapter is not registered with
    ///     the locator.
    ///
    ///   - InvalidReplicaGroupIdException - Raised if the given
    ///     replica group doesn't match the one registered with the
    ///     locator registry for this object adapter.
    func setReplicatedAdapterDirectProxy(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, p iceP_p: ObjectPrx?, context: Context? = nil) throws {
        try _impl._invoke(operation: "setReplicatedAdapterDirectProxy",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_adapterId)
                              ostr.write(iceP_replicaGroupId)
                              ostr.write(iceP_p)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AdapterAlreadyActiveException {
                                  throw error
                              } catch let error as AdapterNotFoundException {
                                  throw error
                              } catch let error as InvalidReplicaGroupIdException {
                                  throw error
                              } catch is UserException {}
                          },
                          context: context)
    }

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter adapterId: `Swift.String` The adapter id.
    ///
    /// - parameter replicaGroupId: `Swift.String` The replica group id.
    ///
    /// - parameter p: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setReplicatedAdapterDirectProxyAsync(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, p iceP_p: ObjectPrx?, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setReplicatedAdapterDirectProxy",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_adapterId)
                                      ostr.write(iceP_replicaGroupId)
                                      ostr.write(iceP_p)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterAlreadyActiveException {
                                          throw error
                                      } catch let error as AdapterNotFoundException {
                                          throw error
                                      } catch let error as InvalidReplicaGroupIdException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the process proxy for a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter proxy: `ProcessPrx?` The process proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ServerNotFoundException - Raised if the server cannot
    ///     be found.
    func setServerProcessProxy(id iceP_id: Swift.String, proxy iceP_proxy: ProcessPrx?, context: Context? = nil) throws {
        try _impl._invoke(operation: "setServerProcessProxy",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_id)
                              ostr.write(iceP_proxy)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerNotFoundException {
                                  throw error
                              } catch is UserException {}
                          },
                          context: context)
    }

    /// Set the process proxy for a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter proxy: `ProcessPrx?` The process proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setServerProcessProxyAsync(id iceP_id: Swift.String, proxy iceP_proxy: ProcessPrx?, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setServerProcessProxy",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_proxy)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotFoundException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This inferface should be implemented by services implementing the
/// Ice::Locator interface. It should be advertised through an Ice
/// object with the identity `Ice/LocatorFinder'. This allows clients
/// to retrieve the locator proxy with just the endpoint information of
/// the service.
///
/// LocatorFinderPrx Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
///
///  - getLocatorAsync: Get the locator proxy implemented by the process hosting this finder object.
public protocol LocatorFinderPrx: ObjectPrx {}

internal final class LocatorFinderPrxI: ObjectPrxI, LocatorFinderPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorFinderTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorFinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorFinderPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorFinderPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) throws -> LocatorFinderPrx? {
    return try LocatorFinderPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorFinderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorFinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorFinderPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorFinderPrx.Protocol, facet: Swift.String? = nil) -> LocatorFinderPrx {
    return LocatorFinderPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorFinderPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `LocatorFinderPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: LocatorFinderPrx.Protocol) -> Swift.String {
    return LocatorFinderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorFinderPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorFinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorFinderPrx?` - The extracted proxy
    func read(_ type: LocatorFinderPrx.Protocol) throws -> LocatorFinderPrx? {
        return try read() as LocatorFinderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorFinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorFinderPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorFinderPrx.Protocol) throws -> LocatorFinderPrx? {
        return try read(tag: tag) as LocatorFinderPrxI?
    }
}

/// This inferface should be implemented by services implementing the
/// Ice::Locator interface. It should be advertised through an Ice
/// object with the identity `Ice/LocatorFinder'. This allows clients
/// to retrieve the locator proxy with just the endpoint information of
/// the service.
///
/// LocatorFinderPrx Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
///
///  - getLocatorAsync: Get the locator proxy implemented by the process hosting this finder object.
public extension LocatorFinderPrx {
    /// Get the locator proxy implemented by the process hosting this
    /// finder object. The proxy might point to several replicas.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LocatorPrx?` - The locator proxy.
    func getLocator(context: Context? = nil) throws -> LocatorPrx? {
        return try _impl._invoke(operation: "getLocator",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: LocatorPrx? = try istr.read(LocatorPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the locator proxy implemented by the process hosting this
    /// finder object. The proxy might point to several replicas.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<LocatorPrx?>` - The result of the operation
    func getLocatorAsync(context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<LocatorPrx?> {
        return _impl._invokeAsync(operation: "getLocator",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: LocatorPrx? = try istr.read(LocatorPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `Locator` servants.
public struct LocatorDisp: Disp {
    public let servant: Locator
    private static let defaultObject = ObjectI<LocatorTraits>()

    public init(_ servant: Locator) {
        self.servant = servant
    }

    public func dispatch(request: Request, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        request.startOver()
        switch current.operation {
        case "findAdapterById":
            return try servant._iceD_findAdapterById(incoming: request, current: current)
        case "findObjectById":
            return try servant._iceD_findObjectById(incoming: request, current: current)
        case "getRegistry":
            return try servant._iceD_getRegistry(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The Ice locator interface. This interface is used by clients to
/// lookup adapters and objects. It is also used by servers to get the
/// locator registry proxy.
///
/// The Locator interface is intended to be used by
/// Ice internals and by locator implementations. Regular user code
/// should not attempt to use any functionality of this interface
/// directly.
public protocol Locator {
    /// Find an object by identity and return a proxy that contains
    /// the adapter ID or endpoints which can be used to access the
    /// object.
    ///
    /// - parameter id: `Identity` The identity.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<ObjectPrx?>` - The result of the operation
    func findObjectByIdAsync(id: Identity, current: Current) -> PromiseKit.Promise<ObjectPrx?>

    /// Find an adapter by id and return a proxy that contains
    /// its endpoints.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<ObjectPrx?>` - The result of the operation
    func findAdapterByIdAsync(id: Swift.String, current: Current) -> PromiseKit.Promise<ObjectPrx?>

    /// Get the locator registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LocatorRegistryPrx?` - The locator registry.
    func getRegistry(current: Current) throws -> LocatorRegistryPrx?
}


/// Dispatcher for `LocatorRegistry` servants.
public struct LocatorRegistryDisp: Disp {
    public let servant: LocatorRegistry
    private static let defaultObject = ObjectI<LocatorRegistryTraits>()

    public init(_ servant: LocatorRegistry) {
        self.servant = servant
    }

    public func dispatch(request: Request, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "setAdapterDirectProxy":
            return try servant._iceD_setAdapterDirectProxy(incoming: request, current: current)
        case "setReplicatedAdapterDirectProxy":
            return try servant._iceD_setReplicatedAdapterDirectProxy(incoming: request, current: current)
        case "setServerProcessProxy":
            return try servant._iceD_setServerProcessProxy(incoming: request, current: current)
        default:
            throw OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The Ice locator registry interface. This interface is used by
/// servers to register adapter endpoints with the locator.
///
/// The LocatorRegistry interface is intended to be used
/// by Ice internals and by locator implementations. Regular user
/// code should not attempt to use any functionality of this interface
/// directly.
public protocol LocatorRegistry {
    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setAdapterDirectProxyAsync(id: Swift.String, proxy: ObjectPrx?, current: Current) -> PromiseKit.Promise<Swift.Void>

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter adapterId: `Swift.String` The adapter id.
    ///
    /// - parameter replicaGroupId: `Swift.String` The replica group id.
    ///
    /// - parameter p: `ObjectPrx?` The adapter proxy (a dummy direct proxy created
    /// by the adapter). The direct proxy contains the adapter
    /// endpoints.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setReplicatedAdapterDirectProxyAsync(adapterId: Swift.String, replicaGroupId: Swift.String, p: ObjectPrx?, current: Current) -> PromiseKit.Promise<Swift.Void>

    /// Set the process proxy for a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter proxy: `ProcessPrx?` The process proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setServerProcessProxyAsync(id: Swift.String, proxy: ProcessPrx?, current: Current) -> PromiseKit.Promise<Swift.Void>
}


/// Dispatcher for `LocatorFinder` servants.
public struct LocatorFinderDisp: Disp {
    public let servant: LocatorFinder
    private static let defaultObject = ObjectI<LocatorFinderTraits>()

    public init(_ servant: LocatorFinder) {
        self.servant = servant
    }

    public func dispatch(request: Request, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        request.startOver()
        switch current.operation {
        case "getLocator":
            return try servant._iceD_getLocator(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// This inferface should be implemented by services implementing the
/// Ice::Locator interface. It should be advertised through an Ice
/// object with the identity `Ice/LocatorFinder'. This allows clients
/// to retrieve the locator proxy with just the endpoint information of
/// the service.
public protocol LocatorFinder {
    /// Get the locator proxy implemented by the process hosting this
    /// finder object. The proxy might point to several replicas.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LocatorPrx?` - The locator proxy.
    func getLocator(current: Current) throws -> LocatorPrx?
}

/// The Ice locator interface. This interface is used by clients to
/// lookup adapters and objects. It is also used by servers to get the
/// locator registry proxy.
///
/// The Locator interface is intended to be used by
/// Ice internals and by locator implementations. Regular user code
/// should not attempt to use any functionality of this interface
/// directly.
///
/// Locator Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
public extension Locator {
    func _iceD_findObjectById(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let iceP_id: Identity = try inS.read { istr in
            let iceP_id: Identity = try istr.read()
            return iceP_id
        }

        return inS.setResultPromise(findObjectByIdAsync(id: iceP_id, current: current)) { (ostr, retVals) in
            let iceP_returnValue = retVals
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_findAdapterById(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let iceP_id: Swift.String = try inS.read { istr in
            let iceP_id: Swift.String = try istr.read()
            return iceP_id
        }

        return inS.setResultPromise(findAdapterByIdAsync(id: iceP_id, current: current)) { (ostr, retVals) in
            let iceP_returnValue = retVals
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getRegistry(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getRegistry(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// The Ice locator registry interface. This interface is used by
/// servers to register adapter endpoints with the locator.
///
/// The LocatorRegistry interface is intended to be used
/// by Ice internals and by locator implementations. Regular user
/// code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistry Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
public extension LocatorRegistry {
    func _iceD_setAdapterDirectProxy(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_id, iceP_proxy): (Swift.String, ObjectPrx?) = try inS.read { istr in
            let iceP_id: Swift.String = try istr.read()
            let iceP_proxy: ObjectPrx? = try istr.read(ObjectPrx.self)
            return (iceP_id, iceP_proxy)
        }

        return inS.setResultPromise(setAdapterDirectProxyAsync(id: iceP_id, proxy: iceP_proxy, current: current))
    }

    func _iceD_setReplicatedAdapterDirectProxy(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_adapterId, iceP_replicaGroupId, iceP_p): (Swift.String, Swift.String, ObjectPrx?) = try inS.read { istr in
            let iceP_adapterId: Swift.String = try istr.read()
            let iceP_replicaGroupId: Swift.String = try istr.read()
            let iceP_p: ObjectPrx? = try istr.read(ObjectPrx.self)
            return (iceP_adapterId, iceP_replicaGroupId, iceP_p)
        }

        return inS.setResultPromise(setReplicatedAdapterDirectProxyAsync(adapterId: iceP_adapterId, replicaGroupId: iceP_replicaGroupId, p: iceP_p, current: current))
    }

    func _iceD_setServerProcessProxy(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_id, iceP_proxy): (Swift.String, ProcessPrx?) = try inS.read { istr in
            let iceP_id: Swift.String = try istr.read()
            let iceP_proxy: ProcessPrx? = try istr.read(ProcessPrx.self)
            return (iceP_id, iceP_proxy)
        }

        return inS.setResultPromise(setServerProcessProxyAsync(id: iceP_id, proxy: iceP_proxy, current: current))
    }
}

/// This inferface should be implemented by services implementing the
/// Ice::Locator interface. It should be advertised through an Ice
/// object with the identity `Ice/LocatorFinder'. This allows clients
/// to retrieve the locator proxy with just the endpoint information of
/// the service.
///
/// LocatorFinder Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
public extension LocatorFinder {
    func _iceD_getLocator(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getLocator(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
