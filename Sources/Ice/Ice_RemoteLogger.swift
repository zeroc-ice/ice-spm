//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.7
//
// <auto-generated>
//
// Generated from file `RemoteLogger.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import PromiseKit

/// An enumeration representing the different types of log messages.
public enum LogMessageType: Swift.UInt8 {
    /// PrintMessage The Logger received a print message.
    case PrintMessage = 0
    /// TraceMessage The Logger received a trace message.
    case TraceMessage = 1
    /// WarningMessage The Logger received a warning message.
    case WarningMessage = 2
    /// ErrorMessage The Logger received an error message.
    case ErrorMessage = 3
    public init() {
        self = .PrintMessage
    }
}

/// An `Ice.InputStream` extension to read `LogMessageType` enumerated values from the stream.
public extension InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `LogMessageType` - The enumarated value.
    func read() throws -> LogMessageType {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = LogMessageType(rawValue: rawValue) else {
            throw MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageType` - The enumerated value.
    func read(tag: Swift.Int32) throws -> LogMessageType? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as LogMessageType
    }
}

/// An `Ice.OutputStream` extension to write `LogMessageType` enumerated values to the stream.
public extension OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `LogMessageType` - The enumerator to write.
    func write(_ v: LogMessageType) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `LogMessageType` - The enumerator to write.
    func write(tag: Swift.Int32, value: LogMessageType?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

/// A sequence of LogMessageType
public typealias LogMessageTypeSeq = [LogMessageType]

/// Helper class to read and write `LogMessageTypeSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LogMessageTypeSeqHelper {
    /// Read a `LogMessageTypeSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LogMessageTypeSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream) throws -> LogMessageTypeSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LogMessageTypeSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LogMessageType = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LogMessageTypeSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageTypeSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream, tag: Swift.Int32) throws -> LogMessageTypeSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LogMessageTypeSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LogMessageTypeSeq` - The sequence value to write to the stream.
    public static func write(to ostr: OutputStream, value v: LogMessageTypeSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LogMessageTypeSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessageTypeSeq` The sequence value to write to the stream.
    public static func write(to ostr: OutputStream,  tag: Swift.Int32, value v: LogMessageTypeSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// A complete log message.
public struct LogMessage: Swift.Hashable {
    /// The type of message sent to the Logger.
    public var `type`: LogMessageType = .PrintMessage
    /// The date and time when the Logger received this message, expressed
    /// as the number of microseconds since the Unix Epoch (00:00:00 UTC on 1 January 1970)
    public var timestamp: Swift.Int64 = 0
    /// For a message of type trace, the trace category of this log message;
    /// otherwise, the empty string.
    public var traceCategory: Swift.String = ""
    /// The log message itself.
    public var message: Swift.String = ""

    public init() {}

    public init(`type`: LogMessageType, timestamp: Swift.Int64, traceCategory: Swift.String, message: Swift.String) {
        self.`type` = `type`
        self.timestamp = timestamp
        self.traceCategory = traceCategory
        self.message = message
    }
}

/// An `Ice.InputStream` extension to read `LogMessage` structured values from the stream.
public extension InputStream {
    /// Read a `LogMessage` structured value from the stream.
    ///
    /// - returns: `LogMessage` - The structured value read from the stream.
    func read() throws -> LogMessage {
        var v = LogMessage()
        v.`type` = try self.read()
        v.timestamp = try self.read()
        v.traceCategory = try self.read()
        v.message = try self.read()
        return v
    }

    /// Read an optional `LogMessage?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessage?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LogMessage? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LogMessage
    }
}

/// An `Ice.OutputStream` extension to write `LogMessage` structured values from the stream.
public extension OutputStream {
    /// Write a `LogMessage` structured value to the stream.
    ///
    /// - parameter _: `LogMessage` - The value to write to the stream.
    func write(_ v: LogMessage) {
        self.write(v.`type`)
        self.write(v.timestamp)
        self.write(v.traceCategory)
        self.write(v.message)
    }

    /// Write an optional `LogMessage?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessage?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LogMessage?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of LogMessage.
public typealias LogMessageSeq = [LogMessage]

/// Helper class to read and write `LogMessageSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LogMessageSeqHelper {
    /// Read a `LogMessageSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LogMessageSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream) throws -> LogMessageSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 11)
        var v = LogMessageSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LogMessage = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LogMessageSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream, tag: Swift.Int32) throws -> LogMessageSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LogMessageSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LogMessageSeq` - The sequence value to write to the stream.
    public static func write(to ostr: OutputStream, value v: LogMessageSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LogMessageSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessageSeq` The sequence value to write to the stream.
    public static func write(to ostr: OutputStream,  tag: Swift.Int32, value v: LogMessageSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `RemoteLogger`.
public struct RemoteLoggerTraits: SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Ice::RemoteLogger"]
    public static let staticId = "::Ice::RemoteLogger"
}

/// :nodoc:
public class RemoteLoggerAlreadyAttachedException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return RemoteLoggerAlreadyAttachedException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_RemoteLoggerAlreadyAttachedException() -> UserExceptionTypeResolver {
        return RemoteLoggerAlreadyAttachedException_TypeResolver()
    }
}

/// Thrown when the provided RemoteLogger was previously attached to a LoggerAdmin.
open class RemoteLoggerAlreadyAttachedException: UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Ice::RemoteLoggerAlreadyAttachedException"
    }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: RemoteLoggerAlreadyAttachedException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `LoggerAdmin`.
public struct LoggerAdminTraits: SliceTraits {
    public static let staticIds = ["::Ice::LoggerAdmin", "::Ice::Object"]
    public static let staticId = "::Ice::LoggerAdmin"
}

/// The Ice remote logger interface. An application can implement a
/// RemoteLogger to receive the log messages sent to the local Logger
/// of another Ice application.
///
/// RemoteLoggerPrx Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - initAsync: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
///
///  - logAsync: Log a LogMessage.
public protocol RemoteLoggerPrx: ObjectPrx {}

internal final class RemoteLoggerPrxI: ObjectPrxI, RemoteLoggerPrx {
    public override class func ice_staticId() -> Swift.String {
        return RemoteLoggerTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `RemoteLoggerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `RemoteLoggerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: RemoteLoggerPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) throws -> RemoteLoggerPrx? {
    return try RemoteLoggerPrxI.checkedCast(prx: prx, facet: facet, context: context) as RemoteLoggerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `RemoteLoggerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `RemoteLoggerPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: RemoteLoggerPrx.Protocol, facet: Swift.String? = nil) -> RemoteLoggerPrx {
    return RemoteLoggerPrxI.uncheckedCast(prx: prx, facet: facet) as RemoteLoggerPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `RemoteLoggerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: RemoteLoggerPrx.Protocol) -> Swift.String {
    return RemoteLoggerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `RemoteLoggerPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `RemoteLoggerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RemoteLoggerPrx?` - The extracted proxy
    func read(_ type: RemoteLoggerPrx.Protocol) throws -> RemoteLoggerPrx? {
        return try read() as RemoteLoggerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `RemoteLoggerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RemoteLoggerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: RemoteLoggerPrx.Protocol) throws -> RemoteLoggerPrx? {
        return try read(tag: tag) as RemoteLoggerPrxI?
    }
}

/// The Ice remote logger interface. An application can implement a
/// RemoteLogger to receive the log messages sent to the local Logger
/// of another Ice application.
///
/// RemoteLoggerPrx Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - initAsync: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
///
///  - logAsync: Log a LogMessage.
public extension RemoteLoggerPrx {
    /// init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
    ///
    /// - parameter prefix: `Swift.String` The prefix of the associated local Logger.
    ///
    /// - parameter logMessages: `LogMessageSeq` Old log messages generated before "now".
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func `init`(prefix iceP_prefix: Swift.String, logMessages iceP_logMessages: LogMessageSeq, context: Context? = nil) throws {
        try _impl._invoke(operation: "init",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_prefix)
                              LogMessageSeqHelper.write(to: ostr, value: iceP_logMessages)
                          },
                          context: context)
    }

    /// init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
    ///
    /// - parameter prefix: `Swift.String` The prefix of the associated local Logger.
    ///
    /// - parameter logMessages: `LogMessageSeq` Old log messages generated before "now".
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func initAsync(prefix iceP_prefix: Swift.String, logMessages iceP_logMessages: LogMessageSeq, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "init",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_prefix)
                                      LogMessageSeqHelper.write(to: ostr, value: iceP_logMessages)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Log a LogMessage. Note that log may be called by LoggerAdmin before init.
    ///
    /// - parameter _: `LogMessage` The message to log.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func log(_ iceP_message: LogMessage, context: Context? = nil) throws {
        try _impl._invoke(operation: "log",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_message)
                          },
                          context: context)
    }

    /// Log a LogMessage. Note that log may be called by LoggerAdmin before init.
    ///
    /// - parameter _: `LogMessage` The message to log.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func logAsync(_ iceP_message: LogMessage, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "log",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_message)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the Logger of this admin object's Ice communicator.
///
/// LoggerAdminPrx Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - attachRemoteLoggerAsync: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - detachRemoteLoggerAsync: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
///
///  - getLogAsync: Retrieves log messages recently logged.
public protocol LoggerAdminPrx: ObjectPrx {}

internal final class LoggerAdminPrxI: ObjectPrxI, LoggerAdminPrx {
    public override class func ice_staticId() -> Swift.String {
        return LoggerAdminTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LoggerAdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LoggerAdminPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LoggerAdminPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) throws -> LoggerAdminPrx? {
    return try LoggerAdminPrxI.checkedCast(prx: prx, facet: facet, context: context) as LoggerAdminPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LoggerAdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LoggerAdminPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LoggerAdminPrx.Protocol, facet: Swift.String? = nil) -> LoggerAdminPrx {
    return LoggerAdminPrxI.uncheckedCast(prx: prx, facet: facet) as LoggerAdminPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `LoggerAdminPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: LoggerAdminPrx.Protocol) -> Swift.String {
    return LoggerAdminTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LoggerAdminPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LoggerAdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LoggerAdminPrx?` - The extracted proxy
    func read(_ type: LoggerAdminPrx.Protocol) throws -> LoggerAdminPrx? {
        return try read() as LoggerAdminPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LoggerAdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LoggerAdminPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LoggerAdminPrx.Protocol) throws -> LoggerAdminPrx? {
        return try read(tag: tag) as LoggerAdminPrxI?
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the Logger of this admin object's Ice communicator.
///
/// LoggerAdminPrx Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - attachRemoteLoggerAsync: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - detachRemoteLoggerAsync: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
///
///  - getLogAsync: Retrieves log messages recently logged.
public extension LoggerAdminPrx {
    /// Attaches a RemoteLogger object to the local logger.
    /// attachRemoteLogger calls init on the provided RemoteLogger proxy.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the remote logger wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that the remote logger wishes to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be provided
    /// to init. A negative value requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - RemoteLoggerAlreadyAttachedException - Raised if this remote logger is already
    ///     attached to this admin object.
    func attachRemoteLogger(prx iceP_prx: RemoteLoggerPrx?, messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil) throws {
        try _impl._invoke(operation: "attachRemoteLogger",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_prx)
                              LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                              ostr.write(iceP_traceCategories)
                              ostr.write(iceP_messageMax)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as RemoteLoggerAlreadyAttachedException {
                                  throw error
                              } catch is UserException {}
                          },
                          context: context)
    }

    /// Attaches a RemoteLogger object to the local logger.
    /// attachRemoteLogger calls init on the provided RemoteLogger proxy.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the remote logger wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that the remote logger wishes to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be provided
    /// to init. A negative value requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func attachRemoteLoggerAsync(prx iceP_prx: RemoteLoggerPrx?, messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "attachRemoteLogger",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_prx)
                                      LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                                      ostr.write(iceP_traceCategories)
                                      ostr.write(iceP_messageMax)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RemoteLoggerAlreadyAttachedException {
                                          throw error
                                      } catch is UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Detaches a RemoteLogger object from the local logger.
    ///
    /// - parameter _: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the provided remote logger proxy was detached, and false otherwise.
    func detachRemoteLogger(_ iceP_prx: RemoteLoggerPrx?, context: Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "detachRemoteLogger",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_prx)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Detaches a RemoteLogger object from the local logger.
    ///
    /// - parameter _: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func detachRemoteLoggerAsync(_ iceP_prx: RemoteLoggerPrx?, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "detachRemoteLogger",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_prx)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Retrieves log messages recently logged.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the caller wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that caller wish to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be returned.
    /// A negative value requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LogMessageSeq, prefix: Swift.String)`:
    ///
    ///   - returnValue: `LogMessageSeq` - The Log messages.
    ///
    ///   - prefix: `Swift.String` - The prefix of the associated local logger.
    func getLog(messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil) throws -> (returnValue: LogMessageSeq, prefix: Swift.String) {
        return try _impl._invoke(operation: "getLog",
                                 mode: .Normal,
                                 write: { ostr in
                                     LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                                     ostr.write(iceP_traceCategories)
                                     ostr.write(iceP_messageMax)
                                 },
                                 read: { istr in
                                     let iceP_prefix: Swift.String = try istr.read()
                                     let iceP_returnValue: LogMessageSeq = try LogMessageSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_prefix)
                                 },
                                 context: context)
    }

    /// Retrieves log messages recently logged.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the caller wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that caller wish to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be returned.
    /// A negative value requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LogMessageSeq, prefix: Swift.String)>` - The result of the operation
    func getLogAsync(messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LogMessageSeq, prefix: Swift.String)> {
        return _impl._invokeAsync(operation: "getLog",
                                  mode: .Normal,
                                  write: { ostr in
                                      LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                                      ostr.write(iceP_traceCategories)
                                      ostr.write(iceP_messageMax)
                                  },
                                  read: { istr in
                                      let iceP_prefix: Swift.String = try istr.read()
                                      let iceP_returnValue: LogMessageSeq = try LogMessageSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_prefix)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `RemoteLogger` servants.
public struct RemoteLoggerDisp: Disp {
    public let servant: RemoteLogger
    private static let defaultObject = ObjectI<RemoteLoggerTraits>()

    public init(_ servant: RemoteLogger) {
        self.servant = servant
    }

    public func dispatch(request: Request, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "init":
            return try servant._iceD_init(incoming: request, current: current)
        case "log":
            return try servant._iceD_log(incoming: request, current: current)
        default:
            throw OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The Ice remote logger interface. An application can implement a
/// RemoteLogger to receive the log messages sent to the local Logger
/// of another Ice application.
public protocol RemoteLogger {
    /// init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
    ///
    /// - parameter prefix: `Swift.String` The prefix of the associated local Logger.
    ///
    /// - parameter logMessages: `LogMessageSeq` Old log messages generated before "now".
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func `init`(prefix: Swift.String, logMessages: LogMessageSeq, current: Current) throws

    /// Log a LogMessage. Note that log may be called by LoggerAdmin before init.
    ///
    /// - parameter message: `LogMessage` The message to log.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func log(message: LogMessage, current: Current) throws
}


/// Dispatcher for `LoggerAdmin` servants.
public struct LoggerAdminDisp: Disp {
    public let servant: LoggerAdmin
    private static let defaultObject = ObjectI<LoggerAdminTraits>()

    public init(_ servant: LoggerAdmin) {
        self.servant = servant
    }

    public func dispatch(request: Request, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        request.startOver()
        switch current.operation {
        case "attachRemoteLogger":
            return try servant._iceD_attachRemoteLogger(incoming: request, current: current)
        case "detachRemoteLogger":
            return try servant._iceD_detachRemoteLogger(incoming: request, current: current)
        case "getLog":
            return try servant._iceD_getLog(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the Logger of this admin object's Ice communicator.
public protocol LoggerAdmin {
    /// Attaches a RemoteLogger object to the local logger.
    /// attachRemoteLogger calls init on the provided RemoteLogger proxy.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the remote logger wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that the remote logger wishes to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be provided
    /// to init. A negative value requests all messages available.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - RemoteLoggerAlreadyAttachedException - Raised if this remote logger is already
    ///     attached to this admin object.
    func attachRemoteLogger(prx: RemoteLoggerPrx?, messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: Swift.Int32, current: Current) throws

    /// Detaches a RemoteLogger object from the local logger.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the provided remote logger proxy was detached, and false otherwise.
    func detachRemoteLogger(prx: RemoteLoggerPrx?, current: Current) throws -> Swift.Bool

    /// Retrieves log messages recently logged.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the caller wishes to receive.
    /// An empty list means no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that caller wish to receive.
    /// This parameter is ignored if messageTypes is not empty and does not include trace.
    /// An empty list means no filtering (send all trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be returned.
    /// A negative value requests all messages available.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LogMessageSeq, prefix: Swift.String)`:
    ///
    ///   - returnValue: `LogMessageSeq` - The Log messages.
    ///
    ///   - prefix: `Swift.String` - The prefix of the associated local logger.
    func getLog(messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: Swift.Int32, current: Current) throws -> (returnValue: LogMessageSeq, prefix: Swift.String)
}

/// The Ice remote logger interface. An application can implement a
/// RemoteLogger to receive the log messages sent to the local Logger
/// of another Ice application.
///
/// RemoteLogger Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
public extension RemoteLogger {
    func _iceD_init(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_prefix, iceP_logMessages): (Swift.String, LogMessageSeq) = try inS.read { istr in
            let iceP_prefix: Swift.String = try istr.read()
            let iceP_logMessages: LogMessageSeq = try LogMessageSeqHelper.read(from: istr)
            return (iceP_prefix, iceP_logMessages)
        }

        try self.`init`(prefix: iceP_prefix, logMessages: iceP_logMessages, current: current)

        return inS.setResult()
    }

    func _iceD_log(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let iceP_message: LogMessage = try inS.read { istr in
            let iceP_message: LogMessage = try istr.read()
            return iceP_message
        }

        try self.log(message: iceP_message, current: current)

        return inS.setResult()
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the Logger of this admin object's Ice communicator.
///
/// LoggerAdmin Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
public extension LoggerAdmin {
    func _iceD_attachRemoteLogger(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_prx, iceP_messageTypes, iceP_traceCategories, iceP_messageMax): (RemoteLoggerPrx?, LogMessageTypeSeq, StringSeq, Swift.Int32) = try inS.read { istr in
            let iceP_prx: RemoteLoggerPrx? = try istr.read(RemoteLoggerPrx.self)
            let iceP_messageTypes: LogMessageTypeSeq = try LogMessageTypeSeqHelper.read(from: istr)
            let iceP_traceCategories: StringSeq = try istr.read()
            let iceP_messageMax: Swift.Int32 = try istr.read()
            return (iceP_prx, iceP_messageTypes, iceP_traceCategories, iceP_messageMax)
        }

        try self.attachRemoteLogger(prx: iceP_prx, messageTypes: iceP_messageTypes, traceCategories: iceP_traceCategories, messageMax: iceP_messageMax, current: current)

        return inS.setResult()
    }

    func _iceD_detachRemoteLogger(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let iceP_prx: RemoteLoggerPrx? = try inS.read { istr in
            let iceP_prx: RemoteLoggerPrx? = try istr.read(RemoteLoggerPrx.self)
            return iceP_prx
        }

        let iceP_returnValue = try self.detachRemoteLogger(prx: iceP_prx, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getLog(incoming inS: Incoming, current: Current) throws -> PromiseKit.Promise<OutputStream>? {
        let (iceP_messageTypes, iceP_traceCategories, iceP_messageMax): (LogMessageTypeSeq, StringSeq, Swift.Int32) = try inS.read { istr in
            let iceP_messageTypes: LogMessageTypeSeq = try LogMessageTypeSeqHelper.read(from: istr)
            let iceP_traceCategories: StringSeq = try istr.read()
            let iceP_messageMax: Swift.Int32 = try istr.read()
            return (iceP_messageTypes, iceP_traceCategories, iceP_messageMax)
        }

        let (iceP_returnValue, iceP_prefix) = try self.getLog(messageTypes: iceP_messageTypes, traceCategories: iceP_traceCategories, messageMax: iceP_messageMax, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_prefix)
            LogMessageSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}
