//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.7
//
// <auto-generated>
//
// Generated from file `Registry.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

/// Determines which load sampling interval to use.
public enum LoadSample: Swift.UInt8 {
    /// LoadSample1 Sample every minute.
    case LoadSample1 = 0
    /// LoadSample5 Sample every five minutes.
    case LoadSample5 = 1
    /// LoadSample15 Sample every fifteen minutes.
    case LoadSample15 = 2
    public init() {
        self = .LoadSample1
    }
}

/// An `Ice.InputStream` extension to read `LoadSample` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `LoadSample` - The enumarated value.
    func read() throws -> LoadSample {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = LoadSample(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LoadSample` - The enumerated value.
    func read(tag: Swift.Int32) throws -> LoadSample? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as LoadSample
    }
}

/// An `Ice.OutputStream` extension to write `LoadSample` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `LoadSample` - The enumerator to write.
    func write(_ v: LoadSample) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `LoadSample` - The enumerator to write.
    func write(tag: Swift.Int32, value: LoadSample?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

/// Traits for Slice interface `Query`.
public struct QueryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Query"]
    public static let staticId = "::IceGrid::Query"
}

/// Traits for Slice interface `Registry`.
public struct RegistryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Registry"]
    public static let staticId = "::IceGrid::Registry"
}

/// Traits for Slice interface `Locator`.
public struct LocatorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Locator", "::Ice::Object", "::IceGrid::Locator"]
    public static let staticId = "::IceGrid::Locator"
}

/// The IceGrid query interface. This interface is accessible to
/// Ice clients who wish to look up well-known objects.
///
/// QueryPrx Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByIdAsync: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeAsync: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findObjectByTypeOnLeastLoadedNodeAsync: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllObjectsByTypeAsync: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
///
///  - findAllReplicasAsync: Find all the object replicas associated with the given proxy.
public protocol QueryPrx: Ice.ObjectPrx {}

private final class QueryPrxI: Ice.ObjectPrxI, QueryPrx {
    public override class func ice_staticId() -> Swift.String {
        return QueryTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `QueryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `QueryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: QueryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> QueryPrx? {
    return try QueryPrxI.checkedCast(prx: prx, facet: facet, context: context) as QueryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `QueryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `QueryPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: QueryPrx.Protocol, facet: Swift.String? = nil) -> QueryPrx {
    return QueryPrxI.uncheckedCast(prx: prx, facet: facet) as QueryPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `QueryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: QueryPrx.Protocol) -> Swift.String {
    return QueryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `QueryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `QueryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `QueryPrx?` - The extracted proxy
    func read(_ type: QueryPrx.Protocol) throws -> QueryPrx? {
        return try read() as QueryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `QueryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `QueryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: QueryPrx.Protocol) throws -> QueryPrx? {
        return try read(tag: tag) as QueryPrxI?
    }
}

/// The IceGrid query interface. This interface is accessible to
/// Ice clients who wish to look up well-known objects.
///
/// QueryPrx Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByIdAsync: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeAsync: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findObjectByTypeOnLeastLoadedNodeAsync: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllObjectsByTypeAsync: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
///
///  - findAllReplicasAsync: Find all the object replicas associated with the given proxy.
public extension QueryPrx {
    /// Find a well-known object by identity.
    ///
    /// - parameter _: `Ice.Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null if no such object has been found.
    func findObjectById(_ iceP_id: Ice.Identity, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "findObjectById",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Find a well-known object by identity.
    ///
    /// - parameter _: `Ice.Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func findObjectByIdAsync(_ iceP_id: Ice.Identity, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "findObjectById",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Find a well-known object by type. If there are several objects
    /// registered for the given type, the object is randomly
    /// selected.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByType(_ iceP_type: Swift.String, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "findObjectByType",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_type)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Find a well-known object by type. If there are several objects
    /// registered for the given type, the object is randomly
    /// selected.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func findObjectByTypeAsync(_ iceP_type: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "findObjectByType",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_type)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Find a well-known object by type on the least-loaded node. If
    /// the registry does not know which node hosts the object
    /// (for example, because the object was registered with a direct proxy), the
    /// registry assumes the object is hosted on a node that has a load
    /// average of 1.0.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter sample: `LoadSample` The sampling interval.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByTypeOnLeastLoadedNode(type iceP_type: Swift.String, sample iceP_sample: LoadSample, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "findObjectByTypeOnLeastLoadedNode",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_type)
                                     ostr.write(iceP_sample)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Find a well-known object by type on the least-loaded node. If
    /// the registry does not know which node hosts the object
    /// (for example, because the object was registered with a direct proxy), the
    /// registry assumes the object is hosted on a node that has a load
    /// average of 1.0.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter sample: `LoadSample` The sampling interval.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func findObjectByTypeOnLeastLoadedNodeAsync(type iceP_type: Swift.String, sample iceP_sample: LoadSample, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "findObjectByTypeOnLeastLoadedNode",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_type)
                                      ostr.write(iceP_sample)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Find all the well-known objects with the given type.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies or an empty sequence, if no such objects
    /// have been found.
    func findAllObjectsByType(_ iceP_type: Swift.String, context: Ice.Context? = nil) throws -> Ice.ObjectProxySeq {
        return try _impl._invoke(operation: "findAllObjectsByType",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_type)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Find all the well-known objects with the given type.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectProxySeq>` - The result of the operation
    func findAllObjectsByTypeAsync(_ iceP_type: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectProxySeq> {
        return _impl._invokeAsync(operation: "findAllObjectsByType",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_type)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Find all the object replicas associated with the given
    /// proxy. If the given proxy is not an indirect proxy from a
    /// replica group, an empty sequence is returned.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies of each object replica or an empty sequence,
    /// if the given proxy is not from a replica group.
    func findAllReplicas(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) throws -> Ice.ObjectProxySeq {
        return try _impl._invoke(operation: "findAllReplicas",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_proxy)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Find all the object replicas associated with the given
    /// proxy. If the given proxy is not an indirect proxy from a
    /// replica group, an empty sequence is returned.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectProxySeq>` - The result of the operation
    func findAllReplicasAsync(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectProxySeq> {
        return _impl._invokeAsync(operation: "findAllReplicas",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_proxy)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The IceGrid registry allows clients create sessions
/// directly with the registry.
///
/// RegistryPrx Methods:
///
///  - createSession: Create a client session.
///
///  - createSessionAsync: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createAdminSessionAsync: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createSessionFromSecureConnectionAsync: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - createAdminSessionFromSecureConnectionAsync: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the session timeout.
///
///  - getSessionTimeoutAsync: Get the session timeout.
///
///  - getACMTimeout: Get the value of the ACM timeout.
///
///  - getACMTimeoutAsync: Get the value of the ACM timeout.
public protocol RegistryPrx: Ice.ObjectPrx {}

private final class RegistryPrxI: Ice.ObjectPrxI, RegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return RegistryTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `RegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `RegistryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: RegistryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> RegistryPrx? {
    return try RegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as RegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `RegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `RegistryPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: RegistryPrx.Protocol, facet: Swift.String? = nil) -> RegistryPrx {
    return RegistryPrxI.uncheckedCast(prx: prx, facet: facet) as RegistryPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `RegistryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: RegistryPrx.Protocol) -> Swift.String {
    return RegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `RegistryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `RegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryPrx?` - The extracted proxy
    func read(_ type: RegistryPrx.Protocol) throws -> RegistryPrx? {
        return try read() as RegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `RegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: RegistryPrx.Protocol) throws -> RegistryPrx? {
        return try read(tag: tag) as RegistryPrxI?
    }
}

/// The IceGrid registry allows clients create sessions
/// directly with the registry.
///
/// RegistryPrx Methods:
///
///  - createSession: Create a client session.
///
///  - createSessionAsync: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createAdminSessionAsync: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createSessionFromSecureConnectionAsync: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - createAdminSessionFromSecureConnectionAsync: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the session timeout.
///
///  - getSessionTimeoutAsync: Get the session timeout.
///
///  - getACMTimeout: Get the value of the ACM timeout.
///
///  - getACMTimeoutAsync: Get the value of the ACM timeout.
public extension RegistryPrx {
    /// Create a client session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createSession(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil) throws -> SessionPrx? {
        return try _impl._invoke(operation: "createSession",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_userId)
                                     ostr.write(iceP_password)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Create a client session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<SessionPrx?>` - The result of the operation
    func createSessionAsync(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<SessionPrx?> {
        return _impl._invokeAsync(operation: "createSession",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_userId)
                                      ostr.write(iceP_password)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create an administrative session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createAdminSession(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil) throws -> AdminSessionPrx? {
        return try _impl._invoke(operation: "createAdminSession",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_userId)
                                     ostr.write(iceP_password)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Create an administrative session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<AdminSessionPrx?>` - The result of the operation
    func createAdminSessionAsync(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<AdminSessionPrx?> {
        return _impl._invokeAsync(operation: "createAdminSession",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_userId)
                                      ostr.write(iceP_password)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create a client session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createSessionFromSecureConnection(context: Ice.Context? = nil) throws -> SessionPrx? {
        return try _impl._invoke(operation: "createSessionFromSecureConnection",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Create a client session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<SessionPrx?>` - The result of the operation
    func createSessionFromSecureConnectionAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<SessionPrx?> {
        return _impl._invokeAsync(operation: "createSessionFromSecureConnection",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create an administrative session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createAdminSessionFromSecureConnection(context: Ice.Context? = nil) throws -> AdminSessionPrx? {
        return try _impl._invoke(operation: "createAdminSessionFromSecureConnection",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Create an administrative session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<AdminSessionPrx?>` - The result of the operation
    func createAdminSessionFromSecureConnectionAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<AdminSessionPrx?> {
        return _impl._invokeAsync(operation: "createAdminSessionFromSecureConnection",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the session timeout. If a client or administrative client
    /// doesn't call the session keepAlive method in the time interval
    /// defined by this timeout, IceGrid might reap the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The timeout (in seconds).
    func getSessionTimeout(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getSessionTimeout",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the session timeout. If a client or administrative client
    /// doesn't call the session keepAlive method in the time interval
    /// defined by this timeout, IceGrid might reap the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getSessionTimeoutAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getSessionTimeout",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the value of the ACM timeout. Clients supporting ACM
    /// connection heartbeats can enable them instead of explicitly
    /// sending keep alives requests.
    ///
    /// NOTE: This method is only available since Ice 3.6.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The timeout (in seconds).
    func getACMTimeout(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getACMTimeout",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the value of the ACM timeout. Clients supporting ACM
    /// connection heartbeats can enable them instead of explicitly
    /// sending keep alives requests.
    ///
    /// NOTE: This method is only available since Ice 3.6.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getACMTimeoutAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getACMTimeout",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The IceGrid locator interface provides access to the Query
/// and Registry object of the IceGrid registry.
///
/// LocatorPrx Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalRegistryAsync: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
///
///  - getLocalQueryAsync: Get the proxy of the query object hosted by this IceGrid registry.
public protocol LocatorPrx: Ice.LocatorPrx {}

private final class LocatorPrxI: Ice.ObjectPrxI, LocatorPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> LocatorPrx? {
    return try LocatorPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil) -> LocatorPrx {
    return LocatorPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `LocatorPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: LocatorPrx.Protocol) -> Swift.String {
    return LocatorTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx?` - The extracted proxy
    func read(_ type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read() as LocatorPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read(tag: tag) as LocatorPrxI?
    }
}

/// The IceGrid locator interface provides access to the Query
/// and Registry object of the IceGrid registry.
///
/// LocatorPrx Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalRegistryAsync: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
///
///  - getLocalQueryAsync: Get the proxy of the query object hosted by this IceGrid registry.
public extension LocatorPrx {
    /// Get the proxy of the registry object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `RegistryPrx?` - The proxy of the registry object.
    func getLocalRegistry(context: Ice.Context? = nil) throws -> RegistryPrx? {
        return try _impl._invoke(operation: "getLocalRegistry",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: RegistryPrx? = try istr.read(RegistryPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the proxy of the registry object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<RegistryPrx?>` - The result of the operation
    func getLocalRegistryAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<RegistryPrx?> {
        return _impl._invokeAsync(operation: "getLocalRegistry",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: RegistryPrx? = try istr.read(RegistryPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the proxy of the query object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `QueryPrx?` - The proxy of the query object.
    func getLocalQuery(context: Ice.Context? = nil) throws -> QueryPrx? {
        return try _impl._invoke(operation: "getLocalQuery",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: QueryPrx? = try istr.read(QueryPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the proxy of the query object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<QueryPrx?>` - The result of the operation
    func getLocalQueryAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<QueryPrx?> {
        return _impl._invokeAsync(operation: "getLocalQuery",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: QueryPrx? = try istr.read(QueryPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `Query` servants.
public struct QueryDisp: Ice.Disp {
    public let servant: Query
    private static let defaultObject = Ice.ObjectI<QueryTraits>()

    public init(_ servant: Query) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "findAllObjectsByType":
            return try servant._iceD_findAllObjectsByType(incoming: request, current: current)
        case "findAllReplicas":
            return try servant._iceD_findAllReplicas(incoming: request, current: current)
        case "findObjectById":
            return try servant._iceD_findObjectById(incoming: request, current: current)
        case "findObjectByType":
            return try servant._iceD_findObjectByType(incoming: request, current: current)
        case "findObjectByTypeOnLeastLoadedNode":
            return try servant._iceD_findObjectByTypeOnLeastLoadedNode(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? QueryDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? QueryDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? QueryDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? QueryDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The IceGrid query interface. This interface is accessible to
/// Ice clients who wish to look up well-known objects.
public protocol Query {
    /// Find a well-known object by identity.
    ///
    /// - parameter id: `Ice.Identity` The identity.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null if no such object has been found.
    func findObjectById(id: Ice.Identity, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Find a well-known object by type. If there are several objects
    /// registered for the given type, the object is randomly
    /// selected.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByType(type: Swift.String, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Find a well-known object by type on the least-loaded node. If
    /// the registry does not know which node hosts the object
    /// (for example, because the object was registered with a direct proxy), the
    /// registry assumes the object is hosted on a node that has a load
    /// average of 1.0.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter sample: `LoadSample` The sampling interval.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByTypeOnLeastLoadedNode(type: Swift.String, sample: LoadSample, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Find all the well-known objects with the given type.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies or an empty sequence, if no such objects
    /// have been found.
    func findAllObjectsByType(type: Swift.String, current: Ice.Current) throws -> Ice.ObjectProxySeq

    /// Find all the object replicas associated with the given
    /// proxy. If the given proxy is not an indirect proxy from a
    /// replica group, an empty sequence is returned.
    ///
    /// - parameter proxy: `Ice.ObjectPrx?` The object proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies of each object replica or an empty sequence,
    /// if the given proxy is not from a replica group.
    func findAllReplicas(proxy: Ice.ObjectPrx?, current: Ice.Current) throws -> Ice.ObjectProxySeq
}


/// Dispatcher for `Registry` servants.
public struct RegistryDisp: Ice.Disp {
    public let servant: Registry
    private static let defaultObject = Ice.ObjectI<RegistryTraits>()

    public init(_ servant: Registry) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "createAdminSession":
            return try servant._iceD_createAdminSession(incoming: request, current: current)
        case "createAdminSessionFromSecureConnection":
            return try servant._iceD_createAdminSessionFromSecureConnection(incoming: request, current: current)
        case "createSession":
            return try servant._iceD_createSession(incoming: request, current: current)
        case "createSessionFromSecureConnection":
            return try servant._iceD_createSessionFromSecureConnection(incoming: request, current: current)
        case "getACMTimeout":
            return try servant._iceD_getACMTimeout(incoming: request, current: current)
        case "getSessionTimeout":
            return try servant._iceD_getSessionTimeout(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? RegistryDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? RegistryDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? RegistryDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? RegistryDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The IceGrid registry allows clients create sessions
/// directly with the registry.
public protocol Registry {
    /// Create a client session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createSession(userId: Swift.String, password: Swift.String, current: Ice.Current) throws -> SessionPrx?

    /// Create an administrative session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createAdminSession(userId: Swift.String, password: Swift.String, current: Ice.Current) throws -> AdminSessionPrx?

    /// Create a client session from a secure connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createSessionFromSecureConnection(current: Ice.Current) throws -> SessionPrx?

    /// Create an administrative session from a secure connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for
    ///     the given user id is not correct, or if the user is not allowed
    ///     access.
    func createAdminSessionFromSecureConnection(current: Ice.Current) throws -> AdminSessionPrx?

    /// Get the session timeout. If a client or administrative client
    /// doesn't call the session keepAlive method in the time interval
    /// defined by this timeout, IceGrid might reap the session.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The timeout (in seconds).
    func getSessionTimeout(current: Ice.Current) throws -> Swift.Int32

    /// Get the value of the ACM timeout. Clients supporting ACM
    /// connection heartbeats can enable them instead of explicitly
    /// sending keep alives requests.
    ///
    /// NOTE: This method is only available since Ice 3.6.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The timeout (in seconds).
    func getACMTimeout(current: Ice.Current) throws -> Swift.Int32
}


/// Dispatcher for `Locator` servants.
public struct LocatorDisp: Ice.Disp {
    public let servant: Locator
    private static let defaultObject = Ice.ObjectI<LocatorTraits>()

    public init(_ servant: Locator) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "findAdapterById":
            return try servant._iceD_findAdapterById(incoming: request, current: current)
        case "findObjectById":
            return try servant._iceD_findObjectById(incoming: request, current: current)
        case "getLocalQuery":
            return try servant._iceD_getLocalQuery(incoming: request, current: current)
        case "getLocalRegistry":
            return try servant._iceD_getLocalRegistry(incoming: request, current: current)
        case "getRegistry":
            return try servant._iceD_getRegistry(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? LocatorDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The IceGrid locator interface provides access to the Query
/// and Registry object of the IceGrid registry.
public protocol Locator: Ice.Locator {
    /// Get the proxy of the registry object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `RegistryPrx?` - The proxy of the registry object.
    func getLocalRegistry(current: Ice.Current) throws -> RegistryPrx?

    /// Get the proxy of the query object hosted by this IceGrid
    /// registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `QueryPrx?` - The proxy of the query object.
    func getLocalQuery(current: Ice.Current) throws -> QueryPrx?
}

/// The IceGrid query interface. This interface is accessible to
/// Ice clients who wish to look up well-known objects.
///
/// Query Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
public extension Query {
    func _iceD_findObjectById(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_id: Ice.Identity = try inS.read { istr in
            let iceP_id: Ice.Identity = try istr.read()
            return iceP_id
        }

        let iceP_returnValue = try self.findObjectById(id: iceP_id, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_findObjectByType(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_type: Swift.String = try inS.read { istr in
            let iceP_type: Swift.String = try istr.read()
            return iceP_type
        }

        let iceP_returnValue = try self.findObjectByType(type: iceP_type, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_findObjectByTypeOnLeastLoadedNode(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_type, iceP_sample): (Swift.String, LoadSample) = try inS.read { istr in
            let iceP_type: Swift.String = try istr.read()
            let iceP_sample: LoadSample = try istr.read()
            return (iceP_type, iceP_sample)
        }

        let iceP_returnValue = try self.findObjectByTypeOnLeastLoadedNode(type: iceP_type, sample: iceP_sample, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_findAllObjectsByType(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_type: Swift.String = try inS.read { istr in
            let iceP_type: Swift.String = try istr.read()
            return iceP_type
        }

        let iceP_returnValue = try self.findAllObjectsByType(type: iceP_type, current: current)

        return inS.setResult{ ostr in
            Ice.ObjectProxySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_findAllReplicas(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_proxy: Ice.ObjectPrx? = try inS.read { istr in
            let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            return iceP_proxy
        }

        let iceP_returnValue = try self.findAllReplicas(proxy: iceP_proxy, current: current)

        return inS.setResult{ ostr in
            Ice.ObjectProxySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

/// The IceGrid registry allows clients create sessions
/// directly with the registry.
///
/// Registry Methods:
///
///  - createSession: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the session timeout.
///
///  - getACMTimeout: Get the value of the ACM timeout.
public extension Registry {
    func _iceD_createSession(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_userId, iceP_password): (Swift.String, Swift.String) = try inS.read { istr in
            let iceP_userId: Swift.String = try istr.read()
            let iceP_password: Swift.String = try istr.read()
            return (iceP_userId, iceP_password)
        }

        let iceP_returnValue = try self.createSession(userId: iceP_userId, password: iceP_password, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_createAdminSession(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_userId, iceP_password): (Swift.String, Swift.String) = try inS.read { istr in
            let iceP_userId: Swift.String = try istr.read()
            let iceP_password: Swift.String = try istr.read()
            return (iceP_userId, iceP_password)
        }

        let iceP_returnValue = try self.createAdminSession(userId: iceP_userId, password: iceP_password, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_createSessionFromSecureConnection(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.createSessionFromSecureConnection(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_createAdminSessionFromSecureConnection(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.createAdminSessionFromSecureConnection(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getSessionTimeout(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getSessionTimeout(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getACMTimeout(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getACMTimeout(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// The IceGrid locator interface provides access to the Query
/// and Registry object of the IceGrid registry.
///
/// Locator Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
public extension Locator {
    func _iceD_getLocalRegistry(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getLocalRegistry(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getLocalQuery(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getLocalQuery(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
