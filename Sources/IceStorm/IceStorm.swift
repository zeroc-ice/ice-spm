//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.7
//
// <auto-generated>
//
// Generated from file `IceStorm.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

/// Information on the topic links.
public struct LinkInfo {
    /// The linked topic.
    public var theTopic: TopicPrx? = nil
    /// The name of the linked topic.
    public var name: Swift.String = ""
    /// The cost of traversing this link.
    public var cost: Swift.Int32 = 0

    public init() {}

    public init(theTopic: TopicPrx?, name: Swift.String, cost: Swift.Int32) {
        self.theTopic = theTopic
        self.name = name
        self.cost = cost
    }
}

/// An `Ice.InputStream` extension to read `LinkInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LinkInfo` structured value from the stream.
    ///
    /// - returns: `LinkInfo` - The structured value read from the stream.
    func read() throws -> LinkInfo {
        var v = LinkInfo()
        v.theTopic = try self.read(TopicPrx.self)
        v.name = try self.read()
        v.cost = try self.read()
        return v
    }

    /// Read an optional `LinkInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LinkInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LinkInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LinkInfo
    }
}

/// An `Ice.OutputStream` extension to write `LinkInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LinkInfo` structured value to the stream.
    ///
    /// - parameter _: `LinkInfo` - The value to write to the stream.
    func write(_ v: LinkInfo) {
        self.write(v.theTopic)
        self.write(v.name)
        self.write(v.cost)
    }

    /// Write an optional `LinkInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LinkInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LinkInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of LinkInfo objects.
public typealias LinkInfoSeq = [LinkInfo]

/// Helper class to read and write `LinkInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LinkInfoSeqHelper {
    /// Read a `LinkInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LinkInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LinkInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 7)
        var v = LinkInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LinkInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LinkInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LinkInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LinkInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LinkInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LinkInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LinkInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LinkInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LinkInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LinkInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// This dictionary represents quality of service parameters.
public typealias QoS = [Swift.String: Swift.String]

/// Helper class to read and write `QoS` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QoSHelper {
    /// Read a `QoS` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `QoS` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QoS {
        let sz = try Swift.Int(istr.readSize())
        var v = QoS()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `QoS?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `QoS` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QoS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `QoS` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `QoS` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QoS) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `QoS?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `QoS` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: QoS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class LinkExists_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return LinkExists.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_LinkExists() -> Ice.UserExceptionTypeResolver {
        return LinkExists_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to create a link
/// that already exists.
open class LinkExists: Ice.UserException {
    /// The name of the linked topic.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::LinkExists"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: LinkExists.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class NoSuchLink_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NoSuchLink.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_NoSuchLink() -> Ice.UserExceptionTypeResolver {
        return NoSuchLink_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to remove a
/// link that does not exist.
open class NoSuchLink: Ice.UserException {
    /// The name of the link that does not exist.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::NoSuchLink"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NoSuchLink.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AlreadySubscribed_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AlreadySubscribed.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_AlreadySubscribed() -> Ice.UserExceptionTypeResolver {
        return AlreadySubscribed_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to subscribe
/// a proxy for which a subscription already exists.
open class AlreadySubscribed: Ice.UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::AlreadySubscribed"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AlreadySubscribed.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class InvalidSubscriber_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InvalidSubscriber.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_InvalidSubscriber() -> Ice.UserExceptionTypeResolver {
        return InvalidSubscriber_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to subscribe
/// a proxy that is null.
open class InvalidSubscriber: Ice.UserException {
    /// The reason for the failure.
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::InvalidSubscriber"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InvalidSubscriber.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class BadQoS_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return BadQoS.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_BadQoS() -> Ice.UserExceptionTypeResolver {
        return BadQoS_TypeResolver()
    }
}

/// This exception indicates that a subscription failed due to an
/// invalid QoS.
open class BadQoS: Ice.UserException {
    /// The reason for the failure.
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::BadQoS"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BadQoS.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `Topic`.
public struct TopicTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::Topic"]
    public static let staticId = "::IceStorm::Topic"
}

/// Mapping of topic name to topic proxy.
public typealias TopicDict = [Swift.String: TopicPrx?]

/// Helper class to read and write `TopicDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct TopicDictHelper {
    /// Read a `TopicDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `TopicDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> TopicDict {
        let sz = try Swift.Int(istr.readSize())
        var v = TopicDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: TopicPrx? = try istr.read(TopicPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `TopicDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TopicDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> TopicDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `TopicDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `TopicDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: TopicDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `TopicDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `TopicDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: TopicDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class TopicExists_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return TopicExists.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_TopicExists() -> Ice.UserExceptionTypeResolver {
        return TopicExists_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to create a topic
/// that already exists.
open class TopicExists: Ice.UserException {
    /// The name of the topic that already exists.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::TopicExists"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: TopicExists.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class NoSuchTopic_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NoSuchTopic.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_NoSuchTopic() -> Ice.UserExceptionTypeResolver {
        return NoSuchTopic_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to retrieve a
/// topic that does not exist.
open class NoSuchTopic: Ice.UserException {
    /// The name of the topic that does not exist.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStorm::NoSuchTopic"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NoSuchTopic.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `TopicManager`.
public struct TopicManagerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::TopicManager"]
    public static let staticId = "::IceStorm::TopicManager"
}

/// Traits for Slice interface `Finder`.
public struct FinderTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::Finder"]
    public static let staticId = "::IceStorm::Finder"
}

/// Publishers publish information on a particular topic. A topic
/// logically represents a type.
///
/// TopicPrx Methods:
///
///  - getName: Get the name of this topic.
///
///  - getNameAsync: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getPublisherAsync: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisherAsync: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - subscribeAndGetPublisherAsync: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - unsubscribeAsync: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - linkAsync: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - unlinkAsync: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getLinkInfoSeqAsync: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - getSubscribersAsync: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
///
///  - destroyAsync: Destroy the topic.
public protocol TopicPrx: Ice.ObjectPrx {}

private final class TopicPrxI: Ice.ObjectPrxI, TopicPrx {
    public override class func ice_staticId() -> Swift.String {
        return TopicTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TopicPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TopicPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TopicPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TopicPrx? {
    return try TopicPrxI.checkedCast(prx: prx, facet: facet, context: context) as TopicPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TopicPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TopicPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TopicPrx.Protocol, facet: Swift.String? = nil) -> TopicPrx {
    return TopicPrxI.uncheckedCast(prx: prx, facet: facet) as TopicPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `TopicPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: TopicPrx.Protocol) -> Swift.String {
    return TopicTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TopicPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TopicPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicPrx?` - The extracted proxy
    func read(_ type: TopicPrx.Protocol) throws -> TopicPrx? {
        return try read() as TopicPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TopicPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TopicPrx.Protocol) throws -> TopicPrx? {
        return try read(tag: tag) as TopicPrxI?
    }
}

/// Publishers publish information on a particular topic. A topic
/// logically represents a type.
///
/// TopicPrx Methods:
///
///  - getName: Get the name of this topic.
///
///  - getNameAsync: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getPublisherAsync: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisherAsync: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - subscribeAndGetPublisherAsync: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - unsubscribeAsync: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - linkAsync: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - unlinkAsync: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getLinkInfoSeqAsync: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - getSubscribersAsync: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
///
///  - destroyAsync: Destroy the topic.
public extension TopicPrx {
    /// Get the name of this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String` - The name of the topic.
    func getName(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getName",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the name of this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getNameAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getName",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a proxy to a publisher object for this topic. To publish
    /// data to a topic, the publisher calls getPublisher and then
    /// casts to the topic type. An unchecked cast must be used on this
    /// proxy. If a replicated IceStorm deployment is used this call
    /// may return a replicated proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getPublisher(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getPublisher",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get a proxy to a publisher object for this topic. To publish
    /// data to a topic, the publisher calls getPublisher and then
    /// casts to the topic type. An unchecked cast must be used on this
    /// proxy. If a replicated IceStorm deployment is used this call
    /// may return a replicated proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getPublisherAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getPublisher",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a non-replicated proxy to a publisher object for this
    /// topic. To publish data to a topic, the publisher calls
    /// getPublisher and then casts to the topic type. An unchecked
    /// cast must be used on this proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getNonReplicatedPublisher(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getNonReplicatedPublisher",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get a non-replicated proxy to a publisher object for this
    /// topic. To publish data to a topic, the publisher calls
    /// getPublisher and then casts to the topic type. An unchecked
    /// cast must be used on this proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getNonReplicatedPublisherAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getNonReplicatedPublisher",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Subscribe with the given qos to this topic.  A
    /// per-subscriber publisher object is returned.
    ///
    /// - parameter theQoS: `QoS` The quality of service parameters for this
    /// subscription.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The subscriber's proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The per-subscriber publisher object.
    ///
    /// - throws:
    ///
    ///   - AlreadySubscribed - Raised if the subscriber object is
    ///     already subscribed.
    ///
    ///   - BadQoS - Raised if the requested quality of service
    ///     is unavailable or invalid.
    ///
    ///   - InvalidSubscriber - Raised if the subscriber object is null.
    func subscribeAndGetPublisher(theQoS iceP_theQoS: QoS, subscriber iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "subscribeAndGetPublisher",
                                 mode: .Normal,
                                 write: { ostr in
                                     QoSHelper.write(to: ostr, value: iceP_theQoS)
                                     ostr.write(iceP_subscriber)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as AlreadySubscribed {
                                         throw error
                                     } catch let error as BadQoS {
                                         throw error
                                     } catch let error as InvalidSubscriber {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Subscribe with the given qos to this topic.  A
    /// per-subscriber publisher object is returned.
    ///
    /// - parameter theQoS: `QoS` The quality of service parameters for this
    /// subscription.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The subscriber's proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func subscribeAndGetPublisherAsync(theQoS iceP_theQoS: QoS, subscriber iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "subscribeAndGetPublisher",
                                  mode: .Normal,
                                  write: { ostr in
                                      QoSHelper.write(to: ostr, value: iceP_theQoS)
                                      ostr.write(iceP_subscriber)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AlreadySubscribed {
                                          throw error
                                      } catch let error as BadQoS {
                                          throw error
                                      } catch let error as InvalidSubscriber {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Unsubscribe the given subscriber.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The proxy of an existing subscriber.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func unsubscribe(_ iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "unsubscribe",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_subscriber)
                          },
                          context: context)
    }

    /// Unsubscribe the given subscriber.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The proxy of an existing subscriber.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func unsubscribeAsync(_ iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "unsubscribe",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_subscriber)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create a link to the given topic. All events originating
    /// on this topic will also be sent to linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to link to.
    ///
    /// - parameter cost: `Swift.Int32` The cost to the linked topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - LinkExists - Raised if a link to the same topic already
    ///     exists.
    func link(linkTo iceP_linkTo: TopicPrx?, cost iceP_cost: Swift.Int32, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "link",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_linkTo)
                              ostr.write(iceP_cost)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as LinkExists {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Create a link to the given topic. All events originating
    /// on this topic will also be sent to linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to link to.
    ///
    /// - parameter cost: `Swift.Int32` The cost to the linked topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func linkAsync(linkTo iceP_linkTo: TopicPrx?, cost iceP_cost: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "link",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_linkTo)
                                      ostr.write(iceP_cost)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as LinkExists {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the link from this topic to the given topic linkTo.
    ///
    /// - parameter _: `TopicPrx?` The topic to destroy the link to.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - NoSuchLink - Raised if a link to the topic does not exist.
    func unlink(_ iceP_linkTo: TopicPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "unlink",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_linkTo)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as NoSuchLink {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Destroy the link from this topic to the given topic linkTo.
    ///
    /// - parameter _: `TopicPrx?` The topic to destroy the link to.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func unlinkAsync(_ iceP_linkTo: TopicPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "unlink",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_linkTo)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NoSuchLink {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Retrieve information on the current links.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LinkInfoSeq` - A sequence of LinkInfo objects.
    func getLinkInfoSeq(context: Ice.Context? = nil) throws -> LinkInfoSeq {
        return try _impl._invoke(operation: "getLinkInfoSeq",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: LinkInfoSeq = try LinkInfoSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Retrieve information on the current links.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<LinkInfoSeq>` - The result of the operation
    func getLinkInfoSeqAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<LinkInfoSeq> {
        return _impl._invokeAsync(operation: "getLinkInfoSeq",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: LinkInfoSeq = try LinkInfoSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Retrieve the list of subscribers for this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.IdentitySeq` - The sequence of Ice identities for the subscriber objects.
    func getSubscribers(context: Ice.Context? = nil) throws -> Ice.IdentitySeq {
        return try _impl._invoke(operation: "getSubscribers",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Ice.IdentitySeq = try Ice.IdentitySeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Retrieve the list of subscribers for this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.IdentitySeq>` - The result of the operation
    func getSubscribersAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.IdentitySeq> {
        return _impl._invokeAsync(operation: "getSubscribers",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Ice.IdentitySeq = try Ice.IdentitySeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroy(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroy",
                          mode: .Normal,
                          context: context)
    }

    /// Destroy the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroy",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManagerPrx Methods:
///
///  - create: Create a new topic.
///
///  - createAsync: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAsync: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
///
///  - retrieveAllAsync: Retrieve all topics managed by this topic manager.
///
///  - getSliceChecksums: Returns the checksums for the IceStorm Slice definitions.
///
///  - getSliceChecksumsAsync: Returns the checksums for the IceStorm Slice definitions.
public protocol TopicManagerPrx: Ice.ObjectPrx {}

private final class TopicManagerPrxI: Ice.ObjectPrxI, TopicManagerPrx {
    public override class func ice_staticId() -> Swift.String {
        return TopicManagerTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TopicManagerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TopicManagerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TopicManagerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TopicManagerPrx? {
    return try TopicManagerPrxI.checkedCast(prx: prx, facet: facet, context: context) as TopicManagerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TopicManagerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TopicManagerPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TopicManagerPrx.Protocol, facet: Swift.String? = nil) -> TopicManagerPrx {
    return TopicManagerPrxI.uncheckedCast(prx: prx, facet: facet) as TopicManagerPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `TopicManagerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: TopicManagerPrx.Protocol) -> Swift.String {
    return TopicManagerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TopicManagerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TopicManagerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerPrx?` - The extracted proxy
    func read(_ type: TopicManagerPrx.Protocol) throws -> TopicManagerPrx? {
        return try read() as TopicManagerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TopicManagerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TopicManagerPrx.Protocol) throws -> TopicManagerPrx? {
        return try read(tag: tag) as TopicManagerPrxI?
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManagerPrx Methods:
///
///  - create: Create a new topic.
///
///  - createAsync: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAsync: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
///
///  - retrieveAllAsync: Retrieve all topics managed by this topic manager.
///
///  - getSliceChecksums: Returns the checksums for the IceStorm Slice definitions.
///
///  - getSliceChecksumsAsync: Returns the checksums for the IceStorm Slice definitions.
public extension TopicManagerPrx {
    /// Create a new topic. The topic name must be unique.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance.
    ///
    /// - throws:
    ///
    ///   - TopicExists - Raised if a topic with the same name already
    ///     exists.
    func create(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> TopicPrx? {
        return try _impl._invoke(operation: "create",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as TopicExists {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Create a new topic. The topic name must be unique.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<TopicPrx?>` - The result of the operation
    func createAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<TopicPrx?> {
        return _impl._invokeAsync(operation: "create",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as TopicExists {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Retrieve a topic by name.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance.
    ///
    /// - throws:
    ///
    ///   - NoSuchTopic - Raised if the topic does not exist.
    func retrieve(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> TopicPrx? {
        return try _impl._invoke(operation: "retrieve",
                                 mode: .Nonmutating,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NoSuchTopic {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Retrieve a topic by name.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<TopicPrx?>` - The result of the operation
    func retrieveAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<TopicPrx?> {
        return _impl._invokeAsync(operation: "retrieve",
                                  mode: .Nonmutating,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NoSuchTopic {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Retrieve all topics managed by this topic manager.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicDict` - A dictionary of string, topic proxy pairs.
    func retrieveAll(context: Ice.Context? = nil) throws -> TopicDict {
        return try _impl._invoke(operation: "retrieveAll",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: TopicDict = try TopicDictHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Retrieve all topics managed by this topic manager.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<TopicDict>` - The result of the operation
    func retrieveAllAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<TopicDict> {
        return _impl._invokeAsync(operation: "retrieveAll",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: TopicDict = try TopicDictHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Returns the checksums for the IceStorm Slice definitions.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.SliceChecksumDict` - A dictionary mapping Slice type ids to their checksums.
    func getSliceChecksums(context: Ice.Context? = nil) throws -> Ice.SliceChecksumDict {
        return try _impl._invoke(operation: "getSliceChecksums",
                                 mode: .Nonmutating,
                                 read: { istr in
                                     let iceP_returnValue: Ice.SliceChecksumDict = try Ice.SliceChecksumDictHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Returns the checksums for the IceStorm Slice definitions.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.SliceChecksumDict>` - The result of the operation
    func getSliceChecksumsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.SliceChecksumDict> {
        return _impl._invokeAsync(operation: "getSliceChecksums",
                                  mode: .Nonmutating,
                                  read: { istr in
                                      let iceP_returnValue: Ice.SliceChecksumDict = try Ice.SliceChecksumDictHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This inferface is advertised by the IceStorm service through the
/// Ice object with the identity `IceStorm/Finder'. This allows clients
/// to retrieve the topic manager with just the endpoint information of
/// the IceStorm service.
///
/// FinderPrx Methods:
///
///  - getTopicManager: Get the topic manager proxy.
///
///  - getTopicManagerAsync: Get the topic manager proxy.
public protocol FinderPrx: Ice.ObjectPrx {}

private final class FinderPrxI: Ice.ObjectPrxI, FinderPrx {
    public override class func ice_staticId() -> Swift.String {
        return FinderTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FinderPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FinderPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> FinderPrx? {
    return try FinderPrxI.checkedCast(prx: prx, facet: facet, context: context) as FinderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FinderPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FinderPrx.Protocol, facet: Swift.String? = nil) -> FinderPrx {
    return FinderPrxI.uncheckedCast(prx: prx, facet: facet) as FinderPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `FinderPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: FinderPrx.Protocol) -> Swift.String {
    return FinderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FinderPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FinderPrx?` - The extracted proxy
    func read(_ type: FinderPrx.Protocol) throws -> FinderPrx? {
        return try read() as FinderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FinderPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FinderPrx.Protocol) throws -> FinderPrx? {
        return try read(tag: tag) as FinderPrxI?
    }
}

/// This inferface is advertised by the IceStorm service through the
/// Ice object with the identity `IceStorm/Finder'. This allows clients
/// to retrieve the topic manager with just the endpoint information of
/// the IceStorm service.
///
/// FinderPrx Methods:
///
///  - getTopicManager: Get the topic manager proxy.
///
///  - getTopicManagerAsync: Get the topic manager proxy.
public extension FinderPrx {
    /// Get the topic manager proxy. The proxy might point to several
    /// replicas.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicManagerPrx?` - The topic manager proxy.
    func getTopicManager(context: Ice.Context? = nil) throws -> TopicManagerPrx? {
        return try _impl._invoke(operation: "getTopicManager",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: TopicManagerPrx? = try istr.read(TopicManagerPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the topic manager proxy. The proxy might point to several
    /// replicas.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<TopicManagerPrx?>` - The result of the operation
    func getTopicManagerAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<TopicManagerPrx?> {
        return _impl._invokeAsync(operation: "getTopicManager",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: TopicManagerPrx? = try istr.read(TopicManagerPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `Topic` servants.
public struct TopicDisp: Ice.Disp {
    public let servant: Topic
    private static let defaultObject = Ice.ObjectI<TopicTraits>()

    public init(_ servant: Topic) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "destroy":
            return try servant._iceD_destroy(incoming: request, current: current)
        case "getLinkInfoSeq":
            return try servant._iceD_getLinkInfoSeq(incoming: request, current: current)
        case "getName":
            return try servant._iceD_getName(incoming: request, current: current)
        case "getNonReplicatedPublisher":
            return try servant._iceD_getNonReplicatedPublisher(incoming: request, current: current)
        case "getPublisher":
            return try servant._iceD_getPublisher(incoming: request, current: current)
        case "getSubscribers":
            return try servant._iceD_getSubscribers(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? TopicDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? TopicDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? TopicDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? TopicDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "link":
            return try servant._iceD_link(incoming: request, current: current)
        case "subscribeAndGetPublisher":
            return try servant._iceD_subscribeAndGetPublisher(incoming: request, current: current)
        case "unlink":
            return try servant._iceD_unlink(incoming: request, current: current)
        case "unsubscribe":
            return try servant._iceD_unsubscribe(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// Publishers publish information on a particular topic. A topic
/// logically represents a type.
public protocol Topic {
    /// Get the name of this topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String` - The name of the topic.
    func getName(current: Ice.Current) throws -> Swift.String

    /// Get a proxy to a publisher object for this topic. To publish
    /// data to a topic, the publisher calls getPublisher and then
    /// casts to the topic type. An unchecked cast must be used on this
    /// proxy. If a replicated IceStorm deployment is used this call
    /// may return a replicated proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getPublisher(current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Get a non-replicated proxy to a publisher object for this
    /// topic. To publish data to a topic, the publisher calls
    /// getPublisher and then casts to the topic type. An unchecked
    /// cast must be used on this proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getNonReplicatedPublisher(current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Subscribe with the given qos to this topic.  A
    /// per-subscriber publisher object is returned.
    ///
    /// - parameter theQoS: `QoS` The quality of service parameters for this
    /// subscription.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The subscriber's proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The per-subscriber publisher object.
    ///
    /// - throws:
    ///
    ///   - AlreadySubscribed - Raised if the subscriber object is
    ///     already subscribed.
    ///
    ///   - BadQoS - Raised if the requested quality of service
    ///     is unavailable or invalid.
    ///
    ///   - InvalidSubscriber - Raised if the subscriber object is null.
    func subscribeAndGetPublisher(theQoS: QoS, subscriber: Ice.ObjectPrx?, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Unsubscribe the given subscriber.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The proxy of an existing subscriber.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func unsubscribe(subscriber: Ice.ObjectPrx?, current: Ice.Current) throws

    /// Create a link to the given topic. All events originating
    /// on this topic will also be sent to linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to link to.
    ///
    /// - parameter cost: `Swift.Int32` The cost to the linked topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - LinkExists - Raised if a link to the same topic already
    ///     exists.
    func link(linkTo: TopicPrx?, cost: Swift.Int32, current: Ice.Current) throws

    /// Destroy the link from this topic to the given topic linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to destroy the link to.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - NoSuchLink - Raised if a link to the topic does not exist.
    func unlink(linkTo: TopicPrx?, current: Ice.Current) throws

    /// Retrieve information on the current links.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LinkInfoSeq` - A sequence of LinkInfo objects.
    func getLinkInfoSeq(current: Ice.Current) throws -> LinkInfoSeq

    /// Retrieve the list of subscribers for this topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.IdentitySeq` - The sequence of Ice identities for the subscriber objects.
    func getSubscribers(current: Ice.Current) throws -> Ice.IdentitySeq

    /// Destroy the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func destroy(current: Ice.Current) throws
}


/// Dispatcher for `TopicManager` servants.
public struct TopicManagerDisp: Ice.Disp {
    public let servant: TopicManager
    private static let defaultObject = Ice.ObjectI<TopicManagerTraits>()

    public init(_ servant: TopicManager) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "create":
            return try servant._iceD_create(incoming: request, current: current)
        case "getSliceChecksums":
            return try servant._iceD_getSliceChecksums(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? TopicManagerDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? TopicManagerDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? TopicManagerDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? TopicManagerDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "retrieve":
            return try servant._iceD_retrieve(incoming: request, current: current)
        case "retrieveAll":
            return try servant._iceD_retrieveAll(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// A topic manager manages topics, and subscribers to topics.
public protocol TopicManager {
    /// Create a new topic. The topic name must be unique.
    ///
    /// - parameter name: `Swift.String` The name of the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance.
    ///
    /// - throws:
    ///
    ///   - TopicExists - Raised if a topic with the same name already
    ///     exists.
    func create(name: Swift.String, current: Ice.Current) throws -> TopicPrx?

    /// Retrieve a topic by name.
    ///
    /// - parameter name: `Swift.String` The name of the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance.
    ///
    /// - throws:
    ///
    ///   - NoSuchTopic - Raised if the topic does not exist.
    func retrieve(name: Swift.String, current: Ice.Current) throws -> TopicPrx?

    /// Retrieve all topics managed by this topic manager.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicDict` - A dictionary of string, topic proxy pairs.
    func retrieveAll(current: Ice.Current) throws -> TopicDict

    /// Returns the checksums for the IceStorm Slice definitions.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.SliceChecksumDict` - A dictionary mapping Slice type ids to their checksums.
    func getSliceChecksums(current: Ice.Current) throws -> Ice.SliceChecksumDict
}


/// Dispatcher for `Finder` servants.
public struct FinderDisp: Ice.Disp {
    public let servant: Finder
    private static let defaultObject = Ice.ObjectI<FinderTraits>()

    public init(_ servant: Finder) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "getTopicManager":
            return try servant._iceD_getTopicManager(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? FinderDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? FinderDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? FinderDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? FinderDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// This inferface is advertised by the IceStorm service through the
/// Ice object with the identity `IceStorm/Finder'. This allows clients
/// to retrieve the topic manager with just the endpoint information of
/// the IceStorm service.
public protocol Finder {
    /// Get the topic manager proxy. The proxy might point to several
    /// replicas.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicManagerPrx?` - The topic manager proxy.
    func getTopicManager(current: Ice.Current) throws -> TopicManagerPrx?
}

/// Publishers publish information on a particular topic. A topic
/// logically represents a type.
///
/// Topic Methods:
///
///  - getName: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
public extension Topic {
    func _iceD_getName(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getName(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getPublisher(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getPublisher(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getNonReplicatedPublisher(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getNonReplicatedPublisher(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_subscribeAndGetPublisher(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_theQoS, iceP_subscriber): (QoS, Ice.ObjectPrx?) = try inS.read { istr in
            let iceP_theQoS: QoS = try QoSHelper.read(from: istr)
            let iceP_subscriber: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            return (iceP_theQoS, iceP_subscriber)
        }

        let iceP_returnValue = try self.subscribeAndGetPublisher(theQoS: iceP_theQoS, subscriber: iceP_subscriber, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_unsubscribe(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_subscriber: Ice.ObjectPrx? = try inS.read { istr in
            let iceP_subscriber: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            return iceP_subscriber
        }

        try self.unsubscribe(subscriber: iceP_subscriber, current: current)

        return inS.setResult()
    }

    func _iceD_link(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_linkTo, iceP_cost): (TopicPrx?, Swift.Int32) = try inS.read { istr in
            let iceP_linkTo: TopicPrx? = try istr.read(TopicPrx.self)
            let iceP_cost: Swift.Int32 = try istr.read()
            return (iceP_linkTo, iceP_cost)
        }

        try self.link(linkTo: iceP_linkTo, cost: iceP_cost, current: current)

        return inS.setResult()
    }

    func _iceD_unlink(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_linkTo: TopicPrx? = try inS.read { istr in
            let iceP_linkTo: TopicPrx? = try istr.read(TopicPrx.self)
            return iceP_linkTo
        }

        try self.unlink(linkTo: iceP_linkTo, current: current)

        return inS.setResult()
    }

    func _iceD_getLinkInfoSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getLinkInfoSeq(current: current)

        return inS.setResult{ ostr in
            LinkInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_getSubscribers(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getSubscribers(current: current)

        return inS.setResult{ ostr in
            Ice.IdentitySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_destroy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.destroy(current: current)

        return inS.setResult()
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManager Methods:
///
///  - create: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
///
///  - getSliceChecksums: Returns the checksums for the IceStorm Slice definitions.
public extension TopicManager {
    func _iceD_create(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_name: Swift.String = try inS.read { istr in
            let iceP_name: Swift.String = try istr.read()
            return iceP_name
        }

        let iceP_returnValue = try self.create(name: iceP_name, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_retrieve(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_name: Swift.String = try inS.read { istr in
            let iceP_name: Swift.String = try istr.read()
            return iceP_name
        }

        let iceP_returnValue = try self.retrieve(name: iceP_name, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_retrieveAll(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.retrieveAll(current: current)

        return inS.setResult{ ostr in
            TopicDictHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_getSliceChecksums(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getSliceChecksums(current: current)

        return inS.setResult{ ostr in
            Ice.SliceChecksumDictHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

/// This inferface is advertised by the IceStorm service through the
/// Ice object with the identity `IceStorm/Finder'. This allows clients
/// to retrieve the topic manager with just the endpoint information of
/// the IceStorm service.
///
/// Finder Methods:
///
///  - getTopicManager: Get the topic manager proxy.
public extension Finder {
    func _iceD_getTopicManager(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getTopicManager(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
